[TOC]

# 信号

## 概述

很多条件都可以产生信号，所有信号都以SIG开头，在signal.h中信号被定义为正整数常量(信号编号)。不存在编号为0的信号。

很多条件都可以产生信号：

- 在终端按`Ctrl+C`，可以产生终端信号SIGINT。这事停止失去控制程序的办法。
- 硬件产生异常信号。如除数为0或者无效内存引用。硬件通知内核，内核为正在运行的进程产生适当的信号。
- 进程调用kill函数
- 用户调用kill命令
- 某种软件条件发生

信号是异步产生的。信号的到来对于进程来说是不确定的，所以进程不能简单的测试一个变量确定是否来了信号，而是必须告诉内核，在此信号发生后执行以下操作。一般有三种方式进行处理，我们称之为信号处理：

1. 忽略信号。两种信号不能被忽略，就是`SIGKILL`和`SIGSTOP`。是为了保证内核或者超级用户去停止进程的权利。如果顾虑硬件异常信号，进程的运行行为是未定义的
2. 捕捉信号。通知内核，在某个信号发生时，调用某个用户函数，类似与中断处理函数。注意不能捕捉`SIGKILL`和`SIGSTOP`
3. 执行系统默认的动作。大多数信号的默认动作都是终止进程

![1570157758985](pics/10_Signal/1570157758985.png)

![1570157781596](pics/10_Signal/1570157781596.png)

具体信号说明见252页

## 函数signal

```c
//signal.h
void (*signal(int signo, void (*func)(int))) (int);
//成功返回以前的信号处理配置，出错返回SIG_ERR
```

- signo是信号名
- func的值是常量SIG_IGN、常量SIG_DEL或接收到此信号后要调用的函数的地址。
  - SIGDEL表示系统默认动作
  - SIG_IGN表示忽略信号

signal返回一个函数指针，该指针指向的函数无返回值(void)。该函数有一个整形参数，既后面的int

用typedef可以简化：

```c
typedef void Sigfunc(int);
Sigfunc *signal(int, Sigfunc *);
```

## 可重入函数

如果进程捕捉到信号并调用处理函数，正在执行的指令序列就会被替换为信号处理总的指令。处理返回后，继续执行调用前的指令序列。

这会产生一些问题，比如调用信号处理前正在执行malloc申请堆中的内存，此时插入执行信号处理程序，在信号处理时又调用malloc。可能对进程造成破坏，因为malloc通常为所分配的存储区维护一个链表，而执行信号处理函数时，原进程可能正在修改该链表。

又如，在调用处理函数时执行getpwnam，这个函数会将结果存放在静态存储空间，在执行处理函数时又调用了getpwnam，那么结果会覆盖掉原来的。

但是有些函数不会受影响，这些函数是`可重入函数`（意思是可以重新回来不会产生错误），并被称为`异步信号安全(async-signal safe)。除了可重入，在信号处理操作期间，会阻塞任何会引起不一致的信号发送。

![1570161588578](pics/10_Signal/1570161588578.png)

注意：标准IO函数很多实现都以不可重入的方式使用全局数据结构。

## 信号运行原理：

当一些事件造成信号发生，比如进程产生一个信号、硬件异常、软件条件、终端信号或者kill函数调用，内核通常在进程表中以某种形式设置一个标志。这个过程我们称向进程`递送`了一个信号。

信号的`产生`和`递送`之间的时间间隔内，称信号是`未决的(pending)`

信号阻塞是`阻塞信号递送`。如果进程要阻塞某个信号，则该进程将此信号保持为`未决的状态`，直到忽略该信号或者信号解除。

注意，在内核投递信号之前，进程可以决定是否阻塞该信号。

调用sigpending函数可以判定那些信号是设置为阻塞或者未决状态。

`信号屏蔽字signal mask`：每个进程都有，决定了当前要阻塞投递该进程的信号集。可以调用sigprocmask来检测和修改信号屏蔽字。



## kill和raise函数

```c
//signal.h
int kill(pid_t pid int signo);
int raise(int signo);
//成功返回0  出错返回-1
```

raise(signo)等价kill(getpid(),signo);

- signo 信号
- pid
  - pid>0 接收信号的进程iD
  - pid==0 将信号发送给和当前进程属于同一个进程组的所有进程，不包括系统进程集。
  - pid<0 发送给进程组ID等于pid的绝对值的所有进程。当然发送今晨更要具有发送给他们信号的权限。
  - pid==-1 发送给当前进程有权限发送信号的所有进程。不包括系统进程集中的进程。

> 系统进程集包括内核进程和init进程(pid为1)

## 信号发送权限规则

要发送给别的进程需要有权限。但让超级用户用户可以发送给任何的进程以信号。

非超级用户，基本规则：发送者的`实际用户ID`或`有效用户ID`必须等于接受收者的实际用户ID和有效用户ID。实现支持_POSIX_SAVED_IDS，需要检查保存设置用户ID，不是有效用户ID

**特例：**如果发送的信号是SIGCONT，可以发送给属于统一会话的任意其他进程。

## 函数alarm和pause

### alarm

```c
//unistd.h
unsigned int alarm(unsigned int seconds);
//0或以前设置的闹钟剩余秒数
```

如同名字，alarm是闹钟，用来产生SIGALRM信号。这个信号由内核产生。SIGALRM默认动作终止进程。大多数使用闹钟的进程都会捕捉此信号。注意：捕捉信号的处理过程要在alarm调用之前进行。因为可能捕捉处理程序还没安装好闹钟时间就到了，这就默认停止进程。

- seconds=0。如果以前注册的闹钟没到时间，就取消闹钟并且返回剩余时间。
- 其他值，如果有未到时间的闹钟，刷新时间，并返回上次的剩余值。

### pause挂起进程

```c
//unistd.h
int pause(void);
//-1 errno设置为EINTR
```

挂起进程直到捕捉到一个信号。只有执行了信号处理程序并返回时，pause才返回。且返回-1，errno设置为EINTR



## 一般用法

比如，调用signal函数设定SIGALRM信号的处理函数，然后调用alarm设置闹钟，使用pause函数等待返回。





