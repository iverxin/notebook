# 进程关系

[TOC]

## 终端登录

### 终端登录原理

启动过程：

1. 内核创建init进程(ID=1)
2. init读取/etc/ttys，对于每个允许登录的终端设备，调用一次fork
3. 子进程exec getty程序
4. getty程序对终端设备调用open函数，以读写方式将终端打开。一旦终端被打开，文件描述符012就会设置到该设备。
5. getty输出“login”之类的信息，等待用户键入用户名
6. 用户键入用户名后，getty的工作完成，调用login程序。输入密码是login程序处理的

![1569232896868](pics/9_Thread_relationship/1569232896868.png)

现代操作系统支持多个身份验证登录，基本都支持PAM(Pluggable Authentication Modules，可出入的身份验证模块)的方案。允许管理人员配置使用何种身份验证方法来访问那些基于PAM库编写的服务。

服务程序验证用户是否具有适当的权限执行某个服务，两种方案：

- 将身份验证机制编写到应用程序中
- 使用PAM库

如果用户正确登录，login完成的工作：

- 设置工作目录为用户起始目录
- 调用chown更改总段的所有权，使登录用户为所有者
- 对终端设备的访问权限改为“用户读和写”
- 调用setgid和initgroups设置进程的组ID
- 初始化环境
- 更改登录用户ID并调用该用户的shell。
- 等等略，如打印日期消息等

现在登录shell读取启动文件是.profile(Bourne shell和Korn shell)。GUN Bourne-again shell是.bash_profile .bash_login或.profile。



## 网络登录

通过串行终端登录设备和网络登录到系统的主要区别是：

​	终端和计算机之间链接不再是点到点的。

在网络登录时，login只是一种可以使用的服务，和FTP等性质相同。

网络登录所有都经过内核的网络接口驱动程序（如以太网驱动程序）。所以不确定有多少这样的登录，所以等待网络连接请求到达，而不是像串行终端设备那样让一个进程等待可能到来的登录。

### 伪终端

为了使用同一个软件同时处理终端登录和网络登录，使用了`为终端`的软件驱动程序。仿真串行终端的运行行为，将终端操作映射为网络操作。

BSD网络登录：

![1569237049346](pics/9_Thread_relationship/1569237049346.png)

然后：

- telented打开一个为终端设备

- fork两个进程。父进程处理网络连接通信，子进程处理login程序
- 父子进程通过伪终端连接。调用exec之前，子进程文件描述符0/1/2与伪终端相连。

> Linux某些版本使用xinetd代替inetd



## 进程组

每个ID处理有唯一进程ID之外，还属于一个进程组。通常在同一个作业中合起来的。同一进程组各个进程接收统一中断的信号。

### getpgrp 获取进程组ID

```c
//unistd.h
pid_t getpgrp(void);
//调用进程的进程组ID
```



- 每个进程组有一个`组长进程`。`组长进程`的`进程组ID`等于其`进程ID`
- 进程组的组长可以创建一个进程组、创见改组的进程，然后终止。
- 进程组中有一个进程存在，进程组就存在。与组长是否终止无关。
- 进程组的生命周期就是创建到最后一个进程结束或离开。
- 该组最后一个进程可以终止，也可以去别的组

### setpgid 设置组ID

```c
//unistd.h
int setpgid(pid_t pid, pid_t pgid);
//0 -1
```

- 将pid进程的进程组ID设置为pgid
- pid == pgid，则制定为组长

- pid为0，使用当前进程ID
- pgid为0，则pgid=pid

一个进程只能为自己或者子进程设置组ID，但是如果子进程执行exec，则不能更改子进程的进程组ID



大多数作业控制shell中，fork之后调用setpgid，父进程设置子进程的进程组ID，同时子进程自己也要设置一下进程组ID，因为fork后谁先执行无法控制。