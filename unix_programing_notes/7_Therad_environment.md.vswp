vnote_backup_file_826537664 /home/spade/Documents/markdown/unix_programing_notes/7_Therad_environment.md
[TOC]



# 进程环境

## 进程的终止方式

1. main返回
2. 调用exit
3. 调用\_exit 或 _ Exit
4. 最后一个线程从启动例程返回
5. 最后一个线程调用p\_thrad_exit 
6. 异常终止
   - 调用abort
   - 接到信号
   - 最后一个线程对取消请求做出响应

### exit系列退出函数

```c
//stdlib.h iso c声明
void exit(int status);
void _Exit(int status);

//unistd.h  posix.1声明
void _exit(int status);
```

- 区别：
  
- exit会执行标准IO库的清理关闭操作，对所有流fclose，缓冲区会冲洗，写到文件上。
  
- 参数status：`终止状态`。大多数系统shell会提供检查终止状态的方法（例如，echo $? 是输出刚才执行的程序的终止状态）。当然也可以不定义终止状态。

  对于main，return(0);和exit(0); 是等价的。$? 是0



### 进程登记函数atexit

atexit登记的函数，将由exit自动调用，所以这些函数成为`终止处理程序(exit handler)`。

```c
//stdlib.h
int atexit(void (*func)(void));
//成功0，失败负
```

atexit的参数是一个函数地址。这个函数无参数，也无返回参数。exit调用的顺序与登记的顺序**相反**,登记多次可以调用多次。return也会调用这些函数。

自己写内存模型时可以设计内存清理函数，让exit时调用



<img src="linux_programing_pics/7/1568626450349.png" alt="1568626450349" style="zoom:150%;" />

- 内核运行程序的唯一方法是调用exec函数

- 进程自愿终止的方法是显示或者隐式调用_exit或\_Exit。
- 进程可以使用信号非自愿终止



## 环境表

`环境表`是一个字符指针数组

```c
extern char **environ;
```

例如，某个环境有5个字符串，那么environ是一个数组指针，environ[0-4]是这5个字符串的值，其实和char **argv一个道理。

![1568626985133](linux_programing_pics/7/1568626985133.png)

## 程序在存储空间布局

c编译之后的主要组成部分

- 正文段  机器指令部分。通常只读，防止恶意修改

- 初始化数据段   编写时已经赋值的变量。

- 未初始化数据段  也叫bbs段（block started by symbol） 执行之前内核将这里的数据初始化为0或者空指针。通常是函数外的没有赋值的声明。

- 栈   

  - 自动变量
  - 每次函数调用保存的信息
  - 函数调用返回地址和环境信息
  - 当前调用运行的函数里面的变量或者临时分配的存储空间

- 堆  通常是童泰存储分配在堆里。 堆位于未初始化数据段好栈之间。

  ![1568637972096](linux_programing_pics\7\1568637972096.png)

(典型安排，不一定都这样)

### size命令

size命令可以查看各个段的内存安排

```bash
spade@spade-PC:~$ size a.out 
   text	   data	    bss	    dec	    hex	filename
   1944	    616	      8	   2568	    a08	a.out

```





## 环境变量

UNIX内核并不查看这些字符串，解释完全取决于应用程序。

### 获取环境变量：

```c
//stdlib.h
char *getenv(const char *name);
//失败返回NULL
```

- name 

![1568636760244](linux_programing_pics/7/1568636760244.png)

### 设置或者增加环境变量：

![1568636964244](linux_programing_pics\7\1568636964244.png)

```c
//stdlib.h
int putenv(char *str);
//0 非0
int setenv(const char *name, const char *value, int rewrite);
int unsetenv(const char *name);
//0 -1
```

- putenv  name=value字符串放到环境表中，如果name存在，就删除原来的
- setenv 将name设置为value。rewrite非0，将存在的删除。
- unsetname 删除env中的定义

> setenv 和 putenv的区别：
>
> setenv必须分配存储空间，以便根据参数产检name=value的字符串
>
> putenv可以直接把传递给他的字符串放到环境中。很多现实就是这么做的。因此将存放在**栈**中的字符串作为参数传给putenv会发生错误，因为函数返回之后栈会被释放重用。

环境变量和命令参数一起存储在进程存储空间的顶部。栈之上。看上边的图。这使得他原本的空间就是固定的，修改起来十分麻烦：

（1） 如果修改现有的一个name:

​	a. value长度小于原有的，将字符串复制过去就行。

​	b.value长度大于原有的，调用malloc为字符串分配空间，然后使用指针指过去。

（2）增加新的name，更加复杂，因为没有他的地方了。先用malloc分配name=value空间。然后复制到该空间

​	a. 如果这是第一次增加name	

- 调用malloc为新的指z**针表分配**空间。将原来的环境表复制到新的分区。

- 在分区末尾新建指针指向添加的name=value。然后在后面再放一个空指针。

- 指针表原来的项目指向栈之上的environ。

  > 只是指针表移动到了堆中。并且重新定向

  b.不是第一次添加name。只要调用realloc多分配一个至臻空间，然后指向新的字符串。

## 共享库

gcc默认使用共享库技术。共享库技术可以减小程序的体积。

共享库使得可执行文件本身不需要包含公共的库函数，只要在程序第一次执行或者第一次调用某个库函数时，用动态链接的方法与共享库链接。

在程序第一次执行或者共享库第一次调用时会浪费一些时间。

gcc -static hello.c 可以取消使用共享库，静态编译



## 存储空间的分配malloc calloc realloc

```c
//stdlib.h
void *malloc(size_t size);
void *calloc(size_t nobj, size_t size);//制定数量，指定长度。清零
void *realloc(void *ptr, size_t newsize); //增加或减少存储区长度
//成功返回空指针，需要强制转换。失败返回NULL

void free(void *ptr);

alloca() //在栈中申请空间
```

大多数分配的存储空间比要求的稍大一些，用来记录管理信息(分配块的长度、指向下一个分配块的指针等)。

如果超过一个已分配区的尾端或者分配区起始之前进行写操作，则会改另一块的管理记录信息。这种错误是灾难性的。

如果申请空间没有用free释放，那么每次调用这个函数就会增加一块空间，这叫做内存泄漏(leakage).

其他库

1. libmalloc Solaries默认包含
2. vmalloc 
3. quick-fit 速度快，但是可能空间占用大。快速适配
4. jemalloc FreeBSD8.0 默认。
5. TCMalloc 开源可用，高性能、高扩展性、高效率
6. alloc



## setjmp和longjmp

在c中，goto语句不能跨越函数。但是提供跳转函数setjmp和longjmp。

在深层次调用上，如果出错返回，需要结束return一层层一层返回。很麻烦。

```c
//setjmp.h
int setjmp(jmp_buf env);
//直接调用返回0 从longjmp返回则非0
void longjmp(jmp_buf env,  int val);
```

jmp_buf数据类型：是某种形式的数组，存放longjmp时用来恢复栈状态的所有信息。通常env变量是全局变量。



setjmp :希望返回的位置调用setjmp，比如想要返回main，就在main中调用。因为直接调用该函数，所以返回值是0。调用setjmp会把现在的信息记录到jmpbuffer中。

longjmp: 检查到错误时调用。第一个参数是setjmp时用的env，第二个是非0的val。val是setjmp处的返回值。可以有多个longjmp，setjmp可以通过val区分是从哪个返回来的。

```c
//例子：

jmp_buf jmpbuffer; //全局

//main中
if(setjmp(jmpbuffer)!=0)
    printf("error");
while (dosomething){
    //可能在这里调用的函数中出错返回
}

```



## getrlimit和setrlimit

每个进程都有一组资源限制，可以设置下面两个函数进行查询和设置：

```c
//sys/resource.h
int getrlimit(int resource, struct rlimit *rlptr);
int setrlimit(int resource, const struct rlimit *rlptr);
// 0 和非0
```

rlimit{
    
}


