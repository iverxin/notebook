[TOC]

# 进程控制

## 进程标识——进程ID

- 每个进程都有唯一的进程ID，是非负整型，用来标识该进程。

- 进程ID可复用。进程结束后，该ID会分配给其他新的进程。大多数会延迟复用，防止出现错误

- ID为0的是调度进程，也成为交换进程(swapper)。是内核的一部分，不执行任何磁盘上的程序，也是系统进程。

- ID为1是`init进程`。`自举`过程结束后由内核调用。进程文件位于`/etc/init(早期)`，`/sbin/init(较新版本)`。负责在自举内核后启动一个unix系统。通常读取初始化文件(/etc/rc*、/etc/inittab、/etc/init.d中的文件)，引导系统进入一个状态，例如多用户。init不会终止，他是一个用户普通进程。与swapper不同。但是他是root特权下运行的。

  > Mac OS X 10.4 init进程被launchd进程代替。扩展了功能。

- ID 2 是`页守护进程` ，负责支持虚拟存储器系统的分页操作。

获取标识符：

```c
//unistd.h
pid_t getpid(void);
//返回进程ID

pid_t getppid(void);
//调用进程的父进程ID

uid_t getuid(void);
//实际用户ID

uid_t geteuid(void);
//有效用户ID

gid_t getgid(void);
//实际组ID

get_t getegid(void);
//有效阻ID

//都没有出错返回
```



## fork 创建新进程

```c
//unistd.h
pid_t fork(void);
//子进程返回0，父进程返回子进程ID；出错返回-1
```

fork被调用一次，但是返回两次。

子进程的ID返回给父进程的理由：

- 一个进程可以有多个子进程，并且没有函数能一下子获得自己所有子进程的ID。

子进程返回0的理由：

- 一个进程只能够有一个父进程。子进程随时都可以通过getppid获得父进程的ID。



注意：执行fork后，子进程是父进程的副本，获得父进程的数据空间、堆栈的**副本**。他们并不共享这些存储空间部分。**只共享正文段。** 先执行哪个不确定，取决于内核调度。

fork后如果跟随exec，那么子进程并不执行一个父进程数据段、栈、堆的完全副本。使用写时复制（Copy-On-Write）技术。这些区域父进程和子进程共享，并且内核把他们权限设置为只读。任何一个想要修改这些区域，就修改区域的那块内存做副本。

> Linux 3.2提供了clone系统调用，fork的推广，允许操作那部分由父进程和子进程共享。
>
> FreeBSD 8.0提供了rfork

### example:

<img src="pics/8_Thread_control/1568864741601.png" alt="1568864741601" style="zoom:150%;" />

<img src="pics/8_Thread_control/1568864979715.png" alt="1568864979715" style="zoom:150%;" />

注意的点：

- write里面的字符串长度：sizeof计算包括字符串终止符null。避免将null字符输出，所以要减1。 strlen计算不包括null，如果用它就不用减1。他们的区别在于sizeof在编译时就计算长度，而strlen要函数调用。

- 输出到文件和输出到终端，printf打印次数不一样：

  ​	因为标准IO库带缓冲，输出到终端时是行缓冲的，所以遇到换行符，就冲洗缓冲区。printf只输出一次。输出到文件是全缓冲的，fork之前调用了一次printf，结果存放在缓冲区并没有冲洗，调用fork后，缓冲区也被复制到了子进程中，直到exit才冲洗，所以`before fork`被打印两次。



文件共享问题：

在重定向父进程的标准输出时，子进程的标准输出也被重定向。因为fork后复制的是文件描述符，但是他们指向的仍然是同一个文件表项。文件表项由内核维护

例如：

<img src="pics/8_Thread_control/1568867059905.png" alt="1568867059905" style="zoom:150%;" />

- 父进程子进程共享一个文件偏移量。

- 如果写同一个描述指向的文件没有任何同步，他们的输出就会相互混合。



### 其他继承项目

- 实际用户、实际组、有效用户、有效组的ID

- 附属组ID

- 进程组ID
- 回话ID
- 控制终端
- 设置用户ID标志和设置组ID标志
- 当前工作目录
- 根目录
- 文件模式创建屏蔽字
- 信号屏蔽和安排
- close-on-exec标志
- 环境
- 链接的共享存储段
- 存储影响
- 资源限制

区别：

- fork返回值不同
- 进程ID不同
- 父ID不同
- 子进程tms_utme/tms_stime/tms_cutime/tms_ustime设置为0
- 不继承父进程文件锁
- 子进程的未处理闹钟被清除
- 未处理信号设置为空

### fork失败原因

- 系统中现有进程太多
- 实际用户ID进程数超过限制

### fork常见用法

- 父进程赋值自己，父进程子进程同时执行不同代码
- 一个进程要执行另外一个程序，子进程返回后调用exec

## wait和waitpid

### 父子进程结束通讯

进程正常或者异常终止，内核就向它的父进程发送SIGCHLD信号。子进程终止是异步事件，所以内核发送的是异步通知。父进程可以忽略信号，或者提供一个调用函数。默认忽略

### 调用wait waitpid发生什么：

- 所有子进程都在运行，则阻塞
- 如果有一个子进程终止，父进程获取终止状态，取得后立即返回
- 没有子进程就返回报错

### 原型

```c
//sys/wait.h
pid_t wait(int *status);
pid_t waitpid(pid_t pid, int *statloc, int options);
//success：renturn ID，error，0 or -1
```

区别：

- 子进程终止前，调用wait父进程会阻塞，waitpid有可选项options不阻塞
- waitpid并不是等待第一个返回的子进程，可以控制所有等待的进程。

如果子进程已经终止，并且是僵死进程，wait立即返回并取得子进程状态。

statloc是一个整形指针，终止状态存放在这里。可以设置为空指针，不获取状态。

pid： 

- ==-1 任何一个进程，此时waitpid和wait等效
- pid>0 等待进程ID与pid相等的子进程
- ==0 等待组ID等于调用进程组的任意子进程
- <-1 等待组ID等于pid绝对值的任意子进程。

options：0或者下面按位与的结果

![1568869032046](pics/8_Thread_control/1568869032046.png)

![1568869196159](pics/8_Thread_control/1568869196159.png)

