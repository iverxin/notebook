[TOC]

# 文件和目录

## stat、fstat、fstatat和lstat 文件信息获取

### 原型

```c
#include <sys/stat.h>
int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int fd, struct stat *buf);
int lstat(const char *restrict pathname, struct stat *restrict buf);
int fstatat(int fd, const char *restrict pathname, struct stat * restrict buf, int flag);
//成功返回0 失败返回-1
```

**stat** 给出pathname， stat函数就会返回和该文件相关的`信息结构`

**fstat** 获得描述符fd上打开的文件的相关信息

**lstat** 功能和stat相似，但是当前文件是一个符号链接的时候，lstat返回的是符号链接的信息，而不是指向的文件信息。

**fstatat** 相对于当前打开目录( fd参数指向这个目录) 的路径返回文件的统计信息。 

- flag参数控制着是否跟随一个符号链接。

  - AT_SYLINK_NOFOLLOW **fstatat**不会跟随符号链接，返回符号链接的本身信息。否则默认情况是返回符号链接所指向的文件信息。
  - AT_FDCWD，并且pathname是一个相对路径，fstatat会计算当前目录的pathname路径，付过pathname是绝对路径，该标志就会忽略。这两种情况，fstatat的作用和stat或lstat一样。

- buf 参数是一个指针，指向一个必须提供的结构，函数来填充buf指向的结构。就是接收函数的返回结果。

  stat具体内容：

  ```c
  struct stat{
  ```

  ![1567146996825](/home/spade/Documents/markdown/linux_programing_pics/1566893155487.png)

  根据实际定义可能结构稍有不同。

## 文件类型

- 普通文件(regular file)： 常见的文件，这种数据是文本还是二进制和内核无关，对于普通文件的解释是由处理该文件的应用程序进行。

- 目录文件(directory file)：这种文件包括了其他`文件名`和指向这些文件的`有关信息的指针` 。对于文件目录，有`读权限`的任何进程都可以读，但是只有`内核` 可以直接写目录文件。进程必须使用本章介绍的函数才能够更改目录。

- 块特殊文件(block special file ): 对设备（磁盘等）带缓冲访问，每次访问用固定长度为单位进行。

  > FreeBSD不再支持块特殊文件，对设备的访问需要通过字符特殊文件进行。

- 字符特殊文件(character special file ) 提供对设备不带缓冲的访问，每次访问的长度可以改变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。

- FIFO 用于进程间通信，也成为`命名管道( named pipe )`

- 套接字 (socket) 进程间的网络通讯，套接字也可以在一台宿主机上进程间的非网络通讯。

- 符号链接(symbolic link) 指向另一个文件，类似win的快捷方式。

文件类型信息在stat结构中的st_mode 中。

![1567147837382](/home/spade/Documents/markdown/linux_programing_pics/1567147837382.png)

图片来自unix环境高级编程。

```c
//使用方法
//判断一个文件是否是常规文件
char *pathname="/etc/passwd";
struct stat buf;
if (lstat(pathname, &buf)<0){
    printf("lstat error");
}
if (S_ISREG(buf.st_mode)) //是该类型返回1
    printf("regular file");
```



## 用户ID和用户组

进程相关联的ID：

- 实际用户ID

- 实际组ID

  实际是谁，取自登录时口令文件中的登录项。一般不变，但是root用户可以改变。

- 有效用户ID

- 有效用户组ID

- 附属组ID

  用于文件访问权限检查，决定了我们的文件访问权限。

- 保存的设置用户ID

- 保存的设置组ID

  有exec函数保存，在执行下一个程序时包含了有效用户ID和有效用户组的副本。作用见setuid

在执行程序文件时，通常有效用户ID等于实际用户，有效用户组等于实际用户组。

但是可以在`文件模式字(st_mode)`中设置一个特殊标志，含义是执行这个文件时，将`进程的有效ID`设置为`所有者的用户ID(st_uid)`。在`文件模式字(st_mode)`中也可以设置另一位，将执行此文件进程的`有效用户组ID` 设置为`文件所有者的ID`

在文件模式字中这两位分别成为`设置用户ID(set-user-ID)位`和` 设置组(set-group-ID)位`。

比如，文件的所有者是超级用户，并且设置了该文件的 `设置用户ID位` ,那么执行这个文件的进程就拥有了超级用户的权限。



## 文件权限

所有的文件类型都有访问权限(access permission)。每个文件有9个访问权限。

| st_mode  |   含义   |
| :------: | :------: |
| S_IRUSER |  用户读  |
| S_IWUSR  |  用户写  |
| S_IXUSR  | 用户执行 |
| S_IRGRP  |   组读   |
| S_IWGRP  |   组写   |
| S_IXGRP  |  组执行  |
| S_IROTH  |  其他读  |
| S_IWOTH  |  其他写  |
| S_IXOTH  | 其他执行 |

chmod命令就是修改这些参数的。

- u 代表usr
- g 代表组
- o 代表其他

**关于文件权限的规则**

- 打开一个文件时，必须要对所`经过的目录`以及`该文件`都具有执行权限。对一个没有执行权限的目录，将看不到里面的任何内容用。
- 读权限决定是否可以打开该文件进行读取。
- 写权限决定是否可以写入一个文件
- 在open函数中指定一个文件O_TRUNC标志，要具有写权限
- 在目录中创建文件，必须具有`写权限`和`执行权限`
- 删除一个文件，必须对目录有`写`和`执行`权限，对文件有`读写权限`
- 如果用exec系列中的任何函数执行文件，必须具有`执行权限`，该文件还应该是`普通文件`



进程处理文件时，内核会对文件访问权限进行测试，也就是对比进程里面的ID和文件的属性ID，具体方法见《unix高级环境变成 第三版》80页。



## 新文件和目录的权限

新文件的用户ID是进程的有效用户ID，用户组ID(1)可以使进程有效组ID，(2)也可能是所在目录的组ID

>FreeBSD和Mac Os 是用（2），Linux 可以使用mount命令修改，默认情况下是先尝试(2)，如果目录组ID没设置，就用(1)

## access和faccessat

